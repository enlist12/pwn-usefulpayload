## 第三章

#### 机器代码

**gcc C语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示**

x86-64是现在笔记本电脑和台式机中最常见处理器的机器语言（指令集架构）



~~~
gcc -Og -o p p1.c
~~~

-Og告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级，否则会导致产生的代码严重变形，难以理解与源代码之间的联系。



**x86-64下**

* 程序计数器 PC 用%rip表示，下一条执行指令在内存的地址
* 程序的内存地址是虚拟地址，用64位的字表示（8字节，16位16进制），高16位必须为0，地址其实只有12位16进制

![image-20240509105306373](C:\Users\29987\AppData\Roaming\Typora\typora-user-images\image-20240509105306373.png)



-S 能够只生成汇编文件

~~~
gcc -Og -S mstore.c
~~~



反编译器，查看机器代码文件内容

~~~
objdump -d pwn
~~~

![image-20240509110216784](C:\Users\29987\AppData\Roaming\Typora\typora-user-images\image-20240509110216784.png)



**数据格式**

intel用术语字表示16位（2字节）的数据类型，32位成为双字，64位成为4字。

int 双字，指针 四字，long 四字



**寄存器**

x86-64下，以rax为例，al为低8位，ax为低16位，eax为低32位。

16个通用目的寄存器存储整数或指针。

生成1字节或2字节的值，其他字节不变，生成4字节的值，高8位16进制置为0



**操作数**

* 立即数，ATT格式中，$-107,$0x1F
* 寄存器，R[]
* 内存引用，M[addr]



#### 汇编代码

##### 传送指令

x86-64限制，传送指令的2个参数不能都是内存地址，要先将源值加载到寄存器中，然后再从寄存器写入目的地址。

寄存器部分大小必须与指令最后一个字符('b','w','l','q')指定的大小匹配。

movl以寄存器为目的时就将高四位设为0

movz 零扩展

movs 符号扩展

**C语言中的指针其实就是地址**

**ATT格式与intel格式的操作数顺序相反**

leaq目的操作数必须是一个寄存器

二元操作，add,sub等，第二个操作数（目的操作数）必须为寄存器或内存位置，第一个可以是立即数，寄存器或内存位置

计算机内部整数一般用补码表示



##### 控制指令

条件码：

* CF：进位标志。
* ZF：零标志，最近操作得出的结果为0.
* SF：符号标志，最近操作得出的结果为负数
* OF：溢出标志，最近操作导致补码溢出。

cmp指令和sub指令一样，只是不更新寄存器

test指令和and指令一样，只是不更新寄存器，常用的有 

~~~
testq %rax,%rax
~~~

检查%rax是负数，零，还是正数

~~~
cmpq b,a
~~~

——>t=a-b,若t=0,则零标志位设为1，若t<0，则符号标志为1。

**跳转指令**

jmp 无条件跳转。

~~~~
jmp (table)  #jmp .L1
jmp *%rax
jmp *(%rax)
~~~~

有条件跳转：

~~~
je==jz #相等时跳转
jne==jnz #不相等时跳转
jg==jnle #大于时跳转
jl==jnge #小于时跳转
~~~

rep 空操作

条件传送：处理器通过使用流水线提高性能，需要预测指令，可能会预测错误，在有分支情况下。条件传送无需预测，但是条件传送有一定的副作用，例如空指针或某个值需要大量的计算，GCC大部分情况下还是使用条件控制。

~~~
cmove #e的含义与set,j一样
cmovz
cmovg
~~~



**循环操作**

依靠条件跳转实现

当一个寄存器的值在程序中有改变时，说明其存储的是一个变量，而不是固定的参数，返回的变量一般一开始就存储在%rax中

-Og 跳转到中间   -O1 guarded-do

switch:跳转表

&& 指向代码位置的指针，开关情况数量比较多，并且值得范围跨度比较小

~~~
jmp *.L4(,%rsi,8)
~~~

空间换时间，只用一次跳转表访问就可以了



#### 过程

##### 栈

过程-->函数的一次执行

x86-64下过程需要的存储空间超过寄存器能够存放的大小，就会在栈上分配空间，这个部分称为过程的栈帧

在这个空间中，保存寄存器的值，分配局部变量，为调用的过程设置参数

许多函数根本不需要栈帧，当所有局部变量都可以保存在寄存器中，该函数不会调用其他任何函数

(不需要以下汇编)

~~~~
push rbp
mov rbp rsp
.....
leave
~~~~

call Q:将A（call下一条指令的地址）压入栈中，将PC（rip）设置为Q的起始地址。

![image-20240511134032147](C:\Users\29987\AppData\Roaming\Typora\typora-user-images\image-20240511134032147.png)

##### 数据传送

有些时候，局部数据必须存放在内存中

* 寄存器不足够存放所有的本地数据
* 对一个局部变量使用地址运算符'&'，因此必须能够为它产生一个地址（例如引用&angr，那么angr必须存储在栈中）
* 某些局部变量是数组或结构

被调用者保存寄存器：%rbx,%rbp,%r12-%r15，当P调用Q时，Q必须保存这些寄存器的值，

也就是：根本不去改变它，或把原始值压入栈中，改变寄存器的值，然后返回前从栈中弹出旧值

其余寄存器，除%rsp外，都是调用者保护寄存器，任意函数都能修改，保存这些数据是调用者的责任。

**所以，%rbp不一定指向函数的基址**



~~~c
int rfact long(n):
//n in %rdi
rfact:
	movq $1,%rax
    cmpq $1,%rdi
    jle .L1
.L2:
    imulq %rdi,%rax
    subq    $1,%rdi
    cmpq    $1,%rdi
    jg         .L2
.L1:
	ret
~~~

**数组**
long P[M] [N],&P[i] [j]=Xp+8*(N * i +j) 

**指针运算**

若p为指向类型为T的数据的指针，p的值为xp，则表达式p+i的值为xp+L*i

**异质的数据结构**

struct，和数组一样......

union，大小等于最大字段的大小

**数据对齐**

原则：任何K字节的基本对象的地址必须是K的倍数，可以提高内存系统的性能

~~~
K                类型
1				 char
2				 short
4    			 int,float
8				 long,double,char*
~~~

结构体：

首地址与各元素大小的最小公倍数对齐，最后大小也要填充为对齐数的倍数

~~~
struct p2{
	int i;
	char c;
	char d;
	long j;
}

i    c     d     j
0     5    6     8      16
~~~

p2要与8对齐,总大小为16

~~~
struct{
	char *a;
	short b;
	double c;
	char d;
	float e;
	char f;
	long g;
	int h;
}

a     b     c      d     e    f    g    h
0     8     16     24    28   32   40   48
~~~

起始位置与8对齐，总大小为56

当所有数据元素的长度都是2的幂时，一种行之有效的策略是按照大小的降序排列元素的结构。

这样可以减少元素之间的间隙填充，减少空间浪费。



**强制对齐**

某些型号的intel和AMD处理器对于有些SSE指令，要求内存地址与16字节对齐，后果是任何内存分配函数(alloca,malloc,calloc,realloc)生成的块的起始地址都必须是16的倍数。

所以有pre_size的复用以及自动填补满0x8

我认为：libc自然分配的都会与0x10对齐，伪造的chunk可能不与0x10对齐，但在低版本下没有检测，libc 2.32开始检测，但某些关于fake chunk的操作触及到SSE指令，并且fake chunk没有对齐的情况下，会造成程序终止。



#### 缓冲区溢出

蠕虫病毒

%rbp作为帧指针，函数整个执行过程中都使得%rbp指向那个时刻的栈位置

较早版本的x86代码中，每个函数都使用了帧指针，但最近版本GCC放弃了这个惯例。

![image-20240512134411538](C:\Users\29987\AppData\Roaming\Typora\typora-user-images\image-20240512134411538.png)



#### 浮点代码

存储在内存或XMM寄存器中，XMM寄存器总共128位，xmm0--->xmm15

* %xmm0-%xmm7最多可以传递8个浮点参数，按照参数列出顺序使用，额外的用栈传递
* 函数使用%xmm0保存返回的浮点数
* 所有xmm寄存器都是调用者保存的

~~~c
double f1(int x,double y,long z)
~~~

x  %edi,y %xmm0,z %rsi

和整数运算操作不同，当代码中用到浮点数，要将所有的常量值分配和初始化存储空间，然后从内存中读入这些值